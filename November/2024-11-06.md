# 📆 2024-11-06

# 🔔 스크럼

- 학습 목표 1 : 토큰 기반 인증(feat. JWT)

<br/>

# 🚀 Today I Learned


## 토큰 기반 인증(feat. JWT)

## 인증과 인가

![!\[image.png\](https://prod-files-secure.s3.us-west-2.amazonaws.com/cf024025-486d-4514-84ae-3a7c5951c17c/69a5ca96-886b-4b88-86ad-34d3abe060a6/image.png)
](https://www.okta.com/sites/default/files/styles/1640w_scaled/public/media/image/2020-10/Authentication_vs_Authorization.png?itok=uBFRCfww)


**[인증(Authentication)]**

인증은 **사용자의 신원을 검증하는 프로세스**이다. 

**[인가(Authorization)]**

인가는 **사용자에게 특정 리소스나 기능에 접근할 수 있는 권한을 부여하는 프로세스**를 말한다.

## JWT (JSON Web Token)

![alt text](https://metamug.com/article/images/security/jwt-token-structure.svg)

JWT는 클라이언트와 서버 간에 **JSON 형식으로 표현된 정보를 안전하게 전달하기 위해 고안된 웹 토큰**이다. 주로 인증과 인가에 많이 사용된다. 

JWT은 다음과 같은 특징을 갖는다.

**1. 자체 포함(Self-Contained) 토큰**

JWT는 **자체적으로 데이터(e.g. 사용자 정보, 토큰 메타 데이터)를 포함**하고 있다.

**2. 무상태(Stateless)**

JWT는 서버에 **상태 정보를 유지하지 않는다**. 따라서, 서버는 클라이언트가 전송하는 JWT의 무결성만 검증하여 사용자를 식별할 수 있다.

JWT의 Stateless한 특성을 활용하여 각 HTTP 요청을 독립적인 상태로 유지할 수 있게 해준다.

**3. 위변조 방지**

JWT는 **서명을 통해 토큰의 위변조를 방지**할 수 있다. 

서명은 주로 HMAC SHA256 또는 RSA 알고리즘을 사용하며 토큰이 변조되지 않았음을 보장한다. 따라서, 서버는 클라이언트가 보낸 JWT가 신뢰할 수 있는 정보인지 검증할 수 있다.


### 구조


JWT는 **헤더, 페이로드, 서명으로 구성**되어 있으며 각 부분을 **Base64Url로 인코딩**하여 이를 **'.' 으로 이어붙인 하나의 문자열**로 이루어져있다.

```
<헤더>.<페이로드>.<서명>
```


**[헤더(Header)]**

헤더는 **토큰의 타입과 서명 알고리즘 정보를 포함**한다. 

이때 서명 알고리즘은 주로 HMAC SHA256(대칭키) 또는 RSA(비대칭 키)를 사용한다.

```json
{
		"alg": "HS256",
		"typ": "JWT"
}
```


**[페이로드(Payload)]**

페이로드는 **클레임(claim)의 형태로 사용자 정보나 권한 정보가 포함**된다. 이때 페이로드는 인코딩만 되어 있기 때문에 **민감한 정보를 포함하는 것을 지양**해야 한다.

클레임은 Key-Value 형태로 데이터를 표현하며 **등록 클레임, 공개 클레임, 비공개 클레임**으로 구성된다.

등록 클레임(Registered Claims)은 JWT 표준에서 정의한 클레임으로 주로 **토큰의 메타 데이터 역할**을 한다.

- iss (issuer) : 토큰 발급자 정보 (e.g. 서버 도메인)
- sub (subject) : 토큰 사용자의 ID 
- aud (audience) : 토큰 대상자 정보 (e.g. 클라이언트 도메인)
- exp (expiration) : 토큰의 만료 시간 (Unix 타임스탬프)
- nbf (not before) : 토큰의 유효 시작 시간
- iat (issued at) : 토큰의 발급 시간
- jti (JWT ID) : 토큰의 고유 식별자

공개 클레임(Public Claims)은 **사용자가 정의한 클레임**이다. 사용자 이름이나 역할과 같은 정보를 포함할 수 있다.

비공개 클레임(Private Claims)은 **특정 클라이언트와 서버 간에 정의된 클레임**이다.

```json
{
  "iss": "https://example.com",
  "sub": "1234567890",
  "aud": "https://service.com",
  "exp": 1711902953,
  "iat": 1711902353,
  "username": "minsoo",
  "role": "admin",
  "department": "engineering"
}
```


**[서명(Signature)]**

서명은 **토큰의 위변조를 방지하는 부분**으로 헤더와 페이로드를 인코딩한 후 서버의 비밀키로 서명되어 생성된다.


## 왜 세션/쿠키 대신 JWT를 써야할까?

### 토큰 기반 인증의 장점

**1. 스케일 아웃에 유리**

토큰 기반 인증은 서버가 상태를 유지하지 않는 Stateless한 특성을 갖기 때문에 **세션이 필요하지 않고 모든 요청에 대해 토큰을 검증**만 해주면 된다.

따라서, 서버를 **수평으로 확장**함에 있어서 서버 간의 동기화나 세션 공유 문제를 고려하지 않아도 되기 때문에 세션 기반 인증보다 간단하게 수행할 수 있다.

**2. 서버의 인증 처리에 대한 부하 감소**

세션 기반 인증에서는 **각 요청마다 세션을 조회**하여 현재 사용자가 유효한지 확인해야 한다. 이는 사용자 수가 늘어날수록 세션 조회 요청이 늘어나기 때문에 서버에 부하를 줄 수 있다.

토큰 기반 인증에서는 **서버가 토큰을 검증하기만 하면** 사용자 인증 정보를 확인할 수 있기 때문에 세션 조회로 인한 부하를 감소시킬 수 있다.


### 토큰 기반 인증의 단점

**1. 클라이언트가 토큰의 관리 주체**

클라이언트가 토큰을 관리하기 때문에 **악의적인 해커에게 토큰을 탈취**당할 수 있고 **발급한 토큰에 대한 제어가 불가능**하다.

이에 대한 해결방안은 다음과 같다.

- HTTPS를 사용하여 토큰을 전송함으로써 탈취를 방지한다.
- 토큰을 브라우저의 로컬 스토리지보다는 쿠키의 HttpOnly 옵션을 통해 저장하여 XSS 공격을 방지할 수 있다.
- 토큰의 만료 시간을 짧게 설정하여 탈취된 토큰의 사용 가능 기간을 최소화한다.
- Refresh Token Rotate 방식을 적용해 악의적인 해커의 토큰 사용을 무효화한다.

**2. 페이로드로 인한 부하 가능성**

페이로드에 많은 데이터를 포함시키게 되면 **네트워크에 부하를 줄 수 있다**.

이에 대한 해결방안은 다음과 같다.

- 페이로드에 포함되는 정보를 최소화하여 토큰의 크기를 줄인다.
- 어쩔 수 없이 JWT 크기가 커질 경우 압축을 통해 토큰의 크기를 줄인다.


## 결론


토큰 기반 인증과 세션 기반 인증은 트레이드 오프가 존재하기 때문에 **애플리케이션의 요구사항에 따라 알맞은 인증 방식을 선택하는 것이 중요**하다.


## Reference

- https://www.okta.com/kr/identity-101/authentication-vs-authorization/

- https://medium.com/@hee98.09.14/token%EC%9D%80-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B1%B8%EA%B9%8C-4411485a580d
<br/>

# 🔥 오늘의 도전 과제와 해결 방법

- JWT와 토큰 기반 인증에 대해서 학습 !

<br/>

# 🗨️ 오늘의 회고

- TIL 작성을 미루지 않고 잘 진행하고 있는 것 같아 뿌듯하다.


<!--
- 오늘의 학습 경험에 대한 자유로운 생각이나 느낀 점을 기록합니다.
- 성공적인 점, 개선해야 할 점, 새롭게 시도하고 싶은 방법 등을 포함할 수 있습니다.-->

