# 📆 2024-10-28

## 🔔 스크럼

- 학습 목표 1 : JS 동작원리

<br/>

## 🚀 Today I Learned

### JS 동작원리

Java나 Python과 같은 멀티 스레드를 지원하는 언어와 달리, JS는 싱글 스레드로 동작하는 언어이다. 하나의 스레드로 구성되어 있기 때문에 **한번에 하나의 작업만 수행**할 수 있다. 

그러나 JS의 특징인 비동기, 논블로킹 I/O 등은 싱글 스레드와 반대되는 개념들이다. 싱글 스레드인데 어떻게 동시성을 가질 수 있는 것일까?

### JS 엔진

![JS 엔진 구성도](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oD61tQl-XxD9YAvd.png)

JS 소스코드를 실행하기 위해서는 JS 엔진이 필요하다. 여기서 JS 엔진은 **JS 코드를 실행하는 프로그램 또는 인터프리터**이다. 대표적인 예로는 구글의 V8이 있다.

JS 엔진은 메모리 힙(Memory Heap)과 콜 스택(Call Stack)으로 구성되어 있다.

JS는 싱글 스레드 기반 언어이기 때문에 한 개의 콜 스택을 갖고있으며, 한 번에 하나의 작업만 처리할 수 있다.

### 콜 스택(Call Stack)

여기서 콜 스택에 대해 더 알아보자. 콜 스택은 JS 엔진이 함수를 호출하고 실행하는 과정에서 **함수 호출 순서를 관리하는 구조**이다.

메인 스레드에서 호출되는 함수들이 콜스택에 쌓이고 이 함수들은 **LIFO(Last In First Out)방식**으로 실행된다.

즉, 특정 함수를 실행하게 되면 해당 함수는 콜 스택의 가장 상단에 위치하게 되고 함수 실행이 끝나게 되면 해당 함수는 콜 스택에서 제거된다.

```javascript
function multiply(x, y) {
		return x * y;		
}

function printSquare(x) {
		var s = multiply(x, x);
		console.log(s);
}

printSqare(5);
```

![콜 스택](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tAapyrLLlAGKHD0u.png)

콜 스택의 각 단계를 스택 프레임(Stack Frame)이라고 하며 코드를 실행하는 과정에서 위 이미지와 같이 변하게 된다.

### JS 런타임 환경

앞서 언급했던 것처럼 JS 엔진은 하나의 콜 스택에 있는 함수를 순차적으로 실행하기 때문에, 다른 작업을 수행하려면 현재 수행중인 작업이 끝날 때까지 기다려야 한다. 

시간이 오래 걸리는 작업이 있을 때 프로그램의 전체 성능 저하로 이어질 수 있다.

따라서, 시간이 오래 걸리는 작업들을 백그라운드에서 처리할 수 있도록 하면 효율적으로 작업을 처리할 수 있을 것이다.

이러한 작업들을 **비동기, 논블로킹 방식으로 처리**하는 JS 런타임 환경이 있다. 여기서 런타임 환경이란 브라우저 or Node.js를 말한다.

JS 엔진은 단순하게 코드를 실행하는 역할만 담당할 뿐, JS 엔진 외부에 있는 런타임 환경이 이벤트를 관리하고 비동기 작업을 처리하여 JS 엔진이 필요할 때마다 실행할 수 있도록 한다.

![alt text](https://miro.medium.com/v2/resize:fit:1400/format:webp/0*H6xu4KPLz9O8htb4.png)

위의 이미지는 JS 엔진과 런타임 환경을 나타낸 모습이다.

런타임 환경에는 이벤트 루프(Event Loop), 콜백 큐(Callback Queue), Web APIs와 같은 구성 요소들이 존재한다.

Web APIs의 경우 런타임 환경이 브라우저일 때 사용하며 런타임 환경이 Node.js라면 Node.js가 지원하는 라이브러리 및 API를 사용한다.

**[이벤트 루프]**

이벤트 발생 시 호출되는 콜백 함수들을 관리하여 태스크 큐에 전달하고, 태스크 큐에 담겨있는 콜백 함수들을 콜 스택에 넘겨준다.

이벤트 루프가 태스크 큐에서 콜 스택으로 콜백 함수를 넘겨주는 작업은 콜 스택에 쌓여있는 함수가 없을 때만 수행된다.

**[태스크 큐]**

Web API에서 비동기 작업들이 실행된 후 호출되는 콜백 함수들이 기다리는 큐이다.

이밴트 루프가 정해준 순서대로 줄을 서있으며, FIFO(First In First Out) 방식을 따른다.

태스크 큐는 Microtask Queue, Animation Frames 등 여러 개의 큐로 이루어져 있다.

**[Web APIs]**

Web APIs는 각각 전용 작업을 처리하는 API 스레드들로 구성된 집합이다. 

DOM Event, AJAX, Timer 등의 비동기 작업들을 수행할 수 있도록 API를 지원한다.

JS 코드들을 실행할 때 Web API가 지원하는 비동기 작업을 수행하는 코드를 실행한다고 가정해보자. 코드는 다음의 순서대로 실행될 것이다.

1. 해당 코드가 콜 스택에 쌓인 후 실행되면, JS 엔진은 비동기 작업을 Web API에게 위임한다.

2. Web API는 해당 비동기 작업을 수행하고 이벤트 루프를 통해 콜백함수를 태스크 큐에 넘겨준다.

3. 이벤트 루프는 콜 스택에 쌓여있는 함수가 없을 때, 태스크 큐에 대기하고 있던 콜백 함수를 콜 스택으로 넘겨준다.

4. 콜 스택에 쌓인 콜백 함수가 실행되고 콜 스택에서 제거된다.

### 예제

```javascript
function foo() {
		console.log('a');
}

function bar() {
		console.log('b');
}

foo();
setTimeout(function () {
		console.log('c');
}, 2000);
bar();
```

JS 엔진은 하나의 콜 스택을 사용하기 때문에 순서대로 a -> b -> c 출력될 것으로 예상할 수 있다. 

그러나 예상과는 다르게 a -> b -> c 순서로 출력된다. 그 이유를 

1. foo()가 콜 스택에 쌓인다.

2. foo()가 실행되고 console.log에 의해 a가 출력된다.

3. foo()가 종료되어 콜 스택에서 제거된다.

4. setTimeOut()가 콜 스택에 쌓인다.

5. setTimeOut()은 Web API가 지원하는 비동기 함수이기 때문에 Web API에 위임하고 콜 스택에서 제거된다.

6. bar()가 콜 스택에 쌓인다.

7. bar()가 실행되고 console.log에 의해 c가 출력된다.

8. bar()가 종료되어 콜 스택에서 제거된다.

9. 이벤트 루프는 콜 스택에 비어있음을 확인하고 태스크 큐에 있는 콜백 함수를 콜 스택으로 전달한다.

10. setTimeout()의 콜백 함수가 실행되고 console.log에 의해 b가 출력된다.

### 결론

JS가 싱글 스레드 방식으로 동작한다는 것은 JS 엔진이 메인 스레드에서 **하나의 콜 스택을 사용해 JS 코드를 실행**한다는 의미이다.

만약 웹 애플리케이션의 모든 JS 코드가 싱글 스레드 방식으로만 동작한다면, 네트워크 요청이나 파일 읽기 등의 **시간이 오래 걸리는 작업을 처리할 때 코드 실행을 멈추고 기다려야 하기 때문에** UI가 멈추거나 응답하지 않는 문제가 발생할 수 있다.

JS 런타임 환경(브라우저와 같은 멀티 스레드 환경)에서는 이러한 작업을 비동기 방식으로 처리하여 문제를 해결한다. 

런타임 환경은 JS 엔진이 아닌 **Web API, 이벤트 루프(Event Loop), 태스크 큐(Task Queue)를 통해 비동기 작업**을 처리한다.

이러한 동작을 통해 JS는 기본적으로 싱글 스레드이지만, 멀티 스레드 환경에서 비동기 작업을 효율적으로 관리할 수 있다.


## 🔥 오늘의 도전 과제와 해결 방법

- Node.js의 파일 시스템 API에 대해서 학습 !

## 🗨️ 오늘의 회고

- 조금씩 공부하는 시간이 늘어나는 것 같아서 뿌듯하다.
- 시간 배분을 잘해야겠다.


<!--
- 오늘의 학습 경험에 대한 자유로운 생각이나 느낀 점을 기록합니다.
- 성공적인 점, 개선해야 할 점, 새롭게 시도하고 싶은 방법 등을 포함할 수 있습니다.-->

