# ğŸ“† 2024-12-16

# ğŸ”” ìŠ¤í¬ëŸ¼

- í•™ìŠµ ëª©í‘œ 1 : ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ MST 
<br/>

# ğŸš€ Today I Learned

## ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (MST)


ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬(Spanning Tree)ëŠ” ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ ì—°ê²°**í•œ ê·¸ë˜í”„ì´ë‹¤. 

ë”°ë¼ì„œ, ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì˜ ì •ì ì´ Nê°œë¼ë©´ ê°„ì„ ì€ N - 1ê°œ ì¡´ì¬í•˜ê²Œ ëœë‹¤.

ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬(MST, Minimum Spanning Tree)ëŠ” ì´ëŸ¬í•œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ ì¤‘ **ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì¸ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬**ì´ë‹¤.

ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ êµ¬í•˜ëŠ” ëŒ€í‘œì ì¸ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ **í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜(Kruskal Algorithm)**ê³¼ **í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜(Prim Algorithm)**ì´ ìˆë‹¤.


## í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ (Kruskalâ€™s Algorithm)

í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì€ **ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜**ì— ê¸°ë°˜í•œ **'ê°„ì„ 'ì¤‘ì‹¬**ì˜ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

ê°„ì„ ì„ **ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ìˆœìœ¼ë¡œ ì •ë ¬**í•˜ê³ , ê°€ì¤‘ì¹˜ê°€ **ì‘ì€ ê°„ì„ ë¶€í„° ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ í•˜ë‚˜ì”© ì„ íƒ**í•˜ë©´ì„œ ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•œë‹¤.

ì‹œê°„ ë³µì¡ë„ëŠ” **O(ElogE)**ì˜ ë³µì¡ë„ë¥¼ ê°–ëŠ”ë‹¤. (E: ê°„ì„ )


### ë™ì‘ê³¼ì •

1. ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¥¼ **ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬**í•œë‹¤.
2. ê°„ì„ ì„ í•˜ë‚˜ì”© ìˆœíšŒí•˜ë©´ì„œ MSTì— í¬í•¨í–ˆì„ ë•Œ **ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šìœ¼ë©´ ì¶”ê°€**í•œë‹¤. (find-union ì•Œê³ ë¦¬ì¦˜)
3. MSTì— ë‹´ê¸´ ê°„ì„ ì˜ ê°œìˆ˜ê°€ **N-1ê°œê°€ ë  ë•Œ ê¹Œì§€ ë°˜ë³µ**í•œë‹¤. (Nì€ ì •ì ì˜ ìˆ˜)

### ì½”ë“œ

```java
public class Kruskal {
    static int V, E;
    static int s, e, v;
    static List<Node> edges;
    static int[] parent;
    static int[] rank;
    static int cost = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        V = Integer.parseInt(st.nextToken());
        E = Integer.parseInt(st.nextToken());

        edges = new ArrayList<>();
        for (int i = 0; i < E; i++) {
            st = new StringTokenizer(br.readLine());
            s = Integer.parseInt(st.nextToken());
            e = Integer.parseInt(st.nextToken());
            v = Integer.parseInt(st.nextToken());
            edges.add(new Node(s, e, v));
        }

        parent = new int[V + 1];
        rank = new int[V + 1];
        for (int i = 1; i <= V; i++) {
            parent[i] = i;
            rank[i] = 1;
       
				// ê°„ì„  ê°€ì¤‘ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
        Collections.sort(edges);

        for (Node edge : edges) {
		        // ì‚¬ì´í´ì´ ìƒê¸°ëŠ”ì§€ í™•ì¸ 
            if (find(edge.s) != find(edge.e)) {
		            // ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šìœ¼ë©´ MSTì— ì¶”ê°€
                union(edge.s, edge.e);
                cost += edge.v;
            }
        }

        System.out.println(cost);
    }

    public static int find(int x) {
        if (parent[x] == x) return x;

        return parent[x] = find(parent[x]);
    }

    public static void union(int x, int y) {
        int a = find(x);
        int b = find(y);

        if (a == b) return;

        if (rank[a] < rank[b]) {
            parent[a] = parent[b];
            rank[b] += rank[a];
        } else {
            parent[b] = parent[a];
            rank[a] += rank[b];
        }
    }
    public static class Node implements Comparable<Node> {
        int s;
        int e;
        int v;

        public Node(int s, int e, int v) {
            this.s = s;
            this.e = e;
            this.v = v;
        }

        public int compareTo(Node o) {
            return this.v - o.v;
        }
    }

}

```

## í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ (Primâ€™s Algorithm)

í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ **ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì— ê¸°ë°˜**í•œ **'ì •ì ' ì¤‘ì‹¬**ì˜ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

ì‹œì‘ ì •ì ì—ì„œ ì¸ì ‘í•œ ì •ì  ì¤‘ **ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì„ íƒ ê°€ëŠ¥í•œ ì •ì ì„ ì„ íƒ**í•˜ê³  ì„ íƒëœ ì •ì ë“¤ ì¤‘ ë‹¤ì‹œ ìµœì†Œ ë¹„ìš©ì„ ì°¾ìœ¼ë©´ì„œ ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•œë‹¤.

ì‹œê°„ ë³µì¡ë„ëŠ” **O(ElogV)**ì˜ ë³µì¡ë„ë¥¼ ê°–ëŠ”ë‹¤. (E: ê°„ì„ , V: ì •ì )

### ë™ì‘ê³¼ì •

í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ **ì‹œì‘ ì •ì ì„ ë¨¼ì € ìš°ì„ ìˆœìœ„ íì— ë„£ê³  ì‹œì‘**í•œë‹¤.

1. ìš°ì„ ìˆœìœ„ íì—ì„œ ì •ì ì„ í•˜ë‚˜ êº¼ë‚¸ë‹¤.
2. êº¼ë‚¸ ì •ì ì´ ì´ë¯¸ MSTì— í¬í•¨ë˜ì–´ ìˆëŠ” ì •ì ì´ë¼ë©´ 1ë²ˆìœ¼ë¡œ ëŒì•„ê°„ë‹¤.
3. ê·¸ë ‡ì§€ ì•Šë‹¤ë©´, ì •ì ê³¼ ì—°ê²°ëœ ê°„ì„ ì„ ì‚´í´ë³´ê³  **ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ìš°ì„ ìˆœìœ„ íì— ì¶”ê°€**í•œë‹¤.
4. **ëª¨ë“  ì •ì ì„ ë°©ë¬¸í•  ë•Œê¹Œì§€** ìœ„ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

### ì½”ë“œ

```java
public class Prim {
    static int V, E;
    static int s, e, v;
    static List<Node>[] graph;
    static boolean[] visited;
    static int cost = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        V = Integer.parseInt(st.nextToken());
        E = Integer.parseInt(st.nextToken());

        graph = new List[V + 1];
        visited = new boolean[V + 1];
        for (int i = 1; i <= V; i++) {
            graph[i] = new ArrayList<>();
        }

        for (int i = 0; i < E; i++) {
            st = new StringTokenizer(br.readLine());
            s = Integer.parseInt(st.nextToken());
            e = Integer.parseInt(st.nextToken());
            v = Integer.parseInt(st.nextToken());

            graph[s].add(new Node(e, v));
            graph[e].add(new Node(s, v));
        }

        prim(1);
    }

    public static void prim(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        
        // ì‹œì‘ ì •ì ì„ ìš°ì„ ìˆœìœ„ íì— ë„£ëŠ”ë‹¤.
        pq.add(new Node(start, 0));
        visited[start] = true;

        while(!pq.isEmpty()) {
		    // ìµœì†Œ ë¹„ìš© ì •ì  êº¼ë‚´ê¸°
            Node n = pq.poll();

            // ì´ë¯¸ í¬í•¨ëœ ì •ì ì€ íŒ¨ìŠ¤
            if (visited[n.e]) continue;
            
            // MSTì— í¬í•¨
            visited[n.e] = true;
            cost += n.v;

            // ì¸ì ‘í•œ ì •ì ì„ ìš°ì„ ìˆœìœ„ íì— ë„£ê¸°
            for (Node next : graph[n.e]) {
                if (!visited[next.e]) {
                    pq.add(next);
                }
            }
        }
    }

    public static class Node implements Comparable<Node> {
        int e;
        int v;

        public Node(int e, int v) {
            this.e = e;
            this.v = v;
        }

        @Override
        public int compareTo(Node o) {
            return this.v - o.v;
        }
    }

}

```

# ğŸ”¥ ì˜¤ëŠ˜ì˜ ë„ì „ ê³¼ì œì™€ í•´ê²° ë°©ë²•

- MSTë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ ë³µì¡ë„, ë™ì‘ ì›ë¦¬, ì½”ë“œë¥¼ ì •ë¦¬

<br/>

# ğŸ—¨ï¸ ì˜¤ëŠ˜ì˜ íšŒê³ 
- MST ìê¾¸ë§Œ ê¹Œë¨¹ëŠ”ë‹¤,, 
- 
<!--
- ì˜¤ëŠ˜ì˜ í•™ìŠµ ê²½í—˜ì— ëŒ€í•œ ììœ ë¡œìš´ ìƒê°ì´ë‚˜ ëŠë‚€ ì ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
- ì„±ê³µì ì¸ ì , ê°œì„ í•´ì•¼ í•  ì , ìƒˆë¡­ê²Œ ì‹œë„í•˜ê³  ì‹¶ì€ ë°©ë²• ë“±ì„ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.-->
