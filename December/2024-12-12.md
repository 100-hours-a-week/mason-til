# 📆 2024-12-12

# 🔔 스크럼

- 학습 목표 1 :  페이지 테이블 크기 줄이기 
<br/>

# 🚀 Today I Learned

## 페이지 테이블 크기 줄이기


기본적인 아이디어의 페이징 기법은 **페이지 테이블의 크기가 크다는 문제**가 있었다.

페이지 크기가 4KB, 페이지 테이블의 각 항목이 4바이트, 32비트 주소 공간인 선형 페이지 테이블을 예로 들면, 페이지 테이블이 많은 공간을 차지한다는 것을 알 수 있다.

32비트 주소 공간에서 페이지 크기가 4KB(2의 12승)이므로 페이지 테이블 항목의 수는 2의 20승으로 백만 개의 가상 페이지가 존재함을 알 수 있다.

이때 페이지 테이블의 각 항목은 4바이트이므로 하나의 페이지 테이블의 크기는 4백만 바이트 즉, 4MB가 된다.

각 프로세스는 하나의 페이지 테이블을 갖기 때문에 100개의 프로세스가 실행중이라면 페이지 테이블을 위해 400MB의 메모리가 필요하게 된다.

따라서, 페이지 테이블의 크기를 줄이기 위한 여러 방법들이 도입되었다.


## 페이지 크기를 키워보기


페이지 테이블의 크기를 간단히 줄일 수 있는 첫 번째 방법은 **페이지 크기를 증가**시키는 것이다.

이전의 예시에서 페이지 크기를 16KB(2의 14승)로 증가시켜보면, 페이지 테이블 항목의 수는 2의 18승이 된다.

마찬가지로, 페이지 테이블 항목의 크기와 수를 곱하게 되면 페이지 테이블의 크기는 1MB으로, 기존에 비해 **4배 감소**된다.

단순히 페이지의 크기를 늘려 해결할 수 있으면 좋겠지만, 가장 큰 문제는 페이지의 크기가 커질수록 페이지 내부 공간의 낭비가 커지게되므로 **내부 단편화가 심해지는 문제**가 있다.

프로세스가 여러 페이지를 할당받아도 할당받은 페이지의 일부부만 사용하게 되기 때문에 메모리 공간이 금방 고갈되는 현상이 발생하게 된다.


## 하이브리드 : 페이징과 세그멘테이션


페이지 테이블의 크기를 줄일 수 있는 두 번째 방법은 **페이징과 세그멘테이션을 적절히 사용**하는 것이다.

이를 쉽게 이해하기 위해 전체 주소 공간 중 **힙과 스택이 아주 작은 부분만 사용**한다고 가정해보자.

![image](https://github.com/user-attachments/assets/09669f79-8987-4aa3-9cd2-fccbe47b6d59)

위의 그림과 같이 사용되는 공간보다 사용되지 않는 공간이 더 많게 페이지 테이블이 구성될 수 있다.

하이브리드 방식은 프로세스의 전체 주소 공간을 위해 하나의 페이지 테이블을 두는 대신 **세그멘트(e.g. 코드, 힙, 스택)마다 페이지 테이블을 각각 두는 것**이다.

세그멘테이션에서는 세그멘트의 시작 주소를 나타내는 **베이스 레지스터**와 세그멘트의 크기를 나타내는 **바운드 레지스터**가 있다.

하이브리드 방식에서도 이와 비슷하게, 세그멘트의 페이지 테이블 시작 주소를 나타내는 베이스 레지스터와 세그멘트의 페이지 테이블 크기를 나타내는 바운드 레지스터를 사용한다.

여기서 핵심은 **세그멘트마다 바운드 레지스터가 존재**한다는 것이다. 바운드 레지스터의 값은 **세그멘트의 최대 페이지 개수**를 나타낸다.

이를 통해 세그멘트의 범위가 넘어가는 곳에 대한 메모리 접근은 예외를 발생시킴으로써 페이지 테이블에 **사용중인 메모리 공간만 유지**할 수 있게된다.

하이브리드 기법 또한 문제가 없는 것은 아닌데, 다양한 크기의 페이지 테이블이 생겨나게 되면서 세그멘테이션의 문제인 **외부 단편화 문제**를 그대로 가져가게 된다.


## 멀티 레벨 페이지 테이블


페이지 테이블의 크기를 줄일 수 있는 마지막 방법은 **멀티 레벨 페이지 테이블**이다. 

멀티 레벨 페이지 테이블은 선형 페이지 테이블을 **트리 구조로 표현**한다. 트리 구조는 다음과 같은 순서로 표현하게 된다.

1. 페이지 테이블을 **페이지 크기의 단위**로 나눈다.
2. 페이지 테이블의 페이지가 유효하지 않은 항목들로만 구성된 경우 해당 페이지는 할당하지 않는다.
3. 페이지 디렉터리를 통해 페이지 테이블의 각 페이지의 할당 여부와 위치를 파악한다.

![image](https://github.com/user-attachments/assets/41fd781b-7128-47ab-8730-dd07f1d46c1e)


페이지 디렉터리의 각 항목은 **선형 페이지 테이블의 한 페이지**를 나타내고, 유효 비트와 페이지 프레임 번호(Page Frame Number, PFN)으로 구성되어 있다.

이때 유효 비트가 1이라면, 페이지 디렉터리 항목이 가리키는 페이지 내에 **최소 하나의 페이지 테이블 항목이 유효하다는 것**을 의미한다. 

반대로 유효 비트가 0이라면, 해당 페이지 내에 유효한 페이지 테이블 항목이 없는 것이므로 **할당하지 않아도 됨**을 의미한다. 이를 통해 페이지 테이블의 크기를 줄일 수 있다.

멀티 레벨 페이지 테이블은 두 개의 장점과 두 개의 단점이 있다.

첫 번째 장점은 멀티 레벨 테이블은 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간이 할당된다. 그렇기 때문에 **작은 크기의 페이지 테이블로 주소 공간을 표현**할 수 있다.

두 번째 장점은 페이지 테이블을 페이지 크기로 분할함으로써 **페이지 테이블을 위한 메모리 할당이 매우 유연**해진다. 선형 페이지 테이블의 경우 연속된 물리 메모리 공간이 필요하지만, 멀티 레벨 페이징에서는 페이지 디렉토리를 통해 각 페이지 테이블의 페이지 위치를 파악할 수 있기 때문이다.

첫 번째 단점은 TLB 미스가 발생했을 때 **두 번의 메모리 참조(페이지 디렉터리와 페이지 테이블 항목 접근)가 필요**하다. 반면, 선형 페이지 테이블에서는 한 번의 메모리 접근으로 TLB 미스를 처리한다.

두 번째 단점은 선형 페이지 테이블에 비해 **페이지 테이블 검색이 복잡**해진다. 

결론적으로 멀티 레벨 페이지 테이블은 **메모리를 아끼고 속도를 포기한 트레이드 오프**라고 할 수 있다.

# 🔥 오늘의 도전 과제와 해결 방법

- 페이지 테이블 크기 줄이기

<br/>

# 🗨️ 오늘의 회고
- 멀티 레벨 페이징에 대해서 학습 완료

<!--
- 오늘의 학습 경험에 대한 자유로운 생각이나 느낀 점을 기록합니다.
- 성공적인 점, 개선해야 할 점, 새롭게 시도하고 싶은 방법 등을 포함할 수 있습니다.-->
